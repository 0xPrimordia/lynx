/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";

export declare namespace IHederaTokenService {
  export type AccountAmountStruct = {
    accountID: AddressLike;
    amount: BigNumberish;
    isApproval: boolean;
  };

  export type AccountAmountStructOutput = [
    accountID: string,
    amount: bigint,
    isApproval: boolean
  ] & { accountID: string; amount: bigint; isApproval: boolean };

  export type NftTransferStruct = {
    senderAccountID: AddressLike;
    receiverAccountID: AddressLike;
    serialNumber: BigNumberish;
    isApproval: boolean;
  };

  export type NftTransferStructOutput = [
    senderAccountID: string,
    receiverAccountID: string,
    serialNumber: bigint,
    isApproval: boolean
  ] & {
    senderAccountID: string;
    receiverAccountID: string;
    serialNumber: bigint;
    isApproval: boolean;
  };

  export type TokenTransferListStruct = {
    token: AddressLike;
    transfers: IHederaTokenService.AccountAmountStruct[];
    nftTransfers: IHederaTokenService.NftTransferStruct[];
  };

  export type TokenTransferListStructOutput = [
    token: string,
    transfers: IHederaTokenService.AccountAmountStructOutput[],
    nftTransfers: IHederaTokenService.NftTransferStructOutput[]
  ] & {
    token: string;
    transfers: IHederaTokenService.AccountAmountStructOutput[];
    nftTransfers: IHederaTokenService.NftTransferStructOutput[];
  };

  export type PendingAirdropStruct = {
    sender: AddressLike;
    receiver: AddressLike;
    token: AddressLike;
    serial: BigNumberish;
  };

  export type PendingAirdropStructOutput = [
    sender: string,
    receiver: string,
    token: string,
    serial: bigint
  ] & { sender: string; receiver: string; token: string; serial: bigint };

  export type ExpiryStruct = {
    second: BigNumberish;
    autoRenewAccount: AddressLike;
    autoRenewPeriod: BigNumberish;
  };

  export type ExpiryStructOutput = [
    second: bigint,
    autoRenewAccount: string,
    autoRenewPeriod: bigint
  ] & { second: bigint; autoRenewAccount: string; autoRenewPeriod: bigint };

  export type HederaTokenStruct = {
    name: string;
    symbol: string;
    treasury: AddressLike;
    memo: string;
    tokenSupplyType: boolean;
    maxSupply: BigNumberish;
    freezeDefault: boolean;
    expiry: IHederaTokenService.ExpiryStruct;
  };

  export type HederaTokenStructOutput = [
    name: string,
    symbol: string,
    treasury: string,
    memo: string,
    tokenSupplyType: boolean,
    maxSupply: bigint,
    freezeDefault: boolean,
    expiry: IHederaTokenService.ExpiryStructOutput
  ] & {
    name: string;
    symbol: string;
    treasury: string;
    memo: string;
    tokenSupplyType: boolean;
    maxSupply: bigint;
    freezeDefault: boolean;
    expiry: IHederaTokenService.ExpiryStructOutput;
  };

  export type FixedFeeStruct = {
    amount: BigNumberish;
    tokenId: AddressLike;
    useHbarsForPayment: boolean;
    useCurrentTokenForPayment: boolean;
    feeCollector: AddressLike;
  };

  export type FixedFeeStructOutput = [
    amount: bigint,
    tokenId: string,
    useHbarsForPayment: boolean,
    useCurrentTokenForPayment: boolean,
    feeCollector: string
  ] & {
    amount: bigint;
    tokenId: string;
    useHbarsForPayment: boolean;
    useCurrentTokenForPayment: boolean;
    feeCollector: string;
  };

  export type FractionalFeeStruct = {
    numerator: BigNumberish;
    denominator: BigNumberish;
    minimumAmount: BigNumberish;
    maximumAmount: BigNumberish;
    netOfTransfers: boolean;
    feeCollector: AddressLike;
  };

  export type FractionalFeeStructOutput = [
    numerator: bigint,
    denominator: bigint,
    minimumAmount: bigint,
    maximumAmount: bigint,
    netOfTransfers: boolean,
    feeCollector: string
  ] & {
    numerator: bigint;
    denominator: bigint;
    minimumAmount: bigint;
    maximumAmount: bigint;
    netOfTransfers: boolean;
    feeCollector: string;
  };

  export type RoyaltyFeeStruct = {
    numerator: BigNumberish;
    denominator: BigNumberish;
    amount: BigNumberish;
    tokenId: AddressLike;
    useHbarsForPayment: boolean;
    feeCollector: AddressLike;
  };

  export type RoyaltyFeeStructOutput = [
    numerator: bigint,
    denominator: bigint,
    amount: bigint,
    tokenId: string,
    useHbarsForPayment: boolean,
    feeCollector: string
  ] & {
    numerator: bigint;
    denominator: bigint;
    amount: bigint;
    tokenId: string;
    useHbarsForPayment: boolean;
    feeCollector: string;
  };

  export type TransferListStruct = {
    transfers: IHederaTokenService.AccountAmountStruct[];
  };

  export type TransferListStructOutput = [
    transfers: IHederaTokenService.AccountAmountStructOutput[]
  ] & { transfers: IHederaTokenService.AccountAmountStructOutput[] };

  export type TokenInfoStruct = {
    token: IHederaTokenService.HederaTokenStruct;
    totalSupply: BigNumberish;
    deleted: boolean;
    defaultKycStatus: boolean;
    pauseStatus: boolean;
    fixedFees: IHederaTokenService.FixedFeeStruct[];
    fractionalFees: IHederaTokenService.FractionalFeeStruct[];
    royaltyFees: IHederaTokenService.RoyaltyFeeStruct[];
    ledgerId: string;
  };

  export type TokenInfoStructOutput = [
    token: IHederaTokenService.HederaTokenStructOutput,
    totalSupply: bigint,
    deleted: boolean,
    defaultKycStatus: boolean,
    pauseStatus: boolean,
    fixedFees: IHederaTokenService.FixedFeeStructOutput[],
    fractionalFees: IHederaTokenService.FractionalFeeStructOutput[],
    royaltyFees: IHederaTokenService.RoyaltyFeeStructOutput[],
    ledgerId: string
  ] & {
    token: IHederaTokenService.HederaTokenStructOutput;
    totalSupply: bigint;
    deleted: boolean;
    defaultKycStatus: boolean;
    pauseStatus: boolean;
    fixedFees: IHederaTokenService.FixedFeeStructOutput[];
    fractionalFees: IHederaTokenService.FractionalFeeStructOutput[];
    royaltyFees: IHederaTokenService.RoyaltyFeeStructOutput[];
    ledgerId: string;
  };

  export type FungibleTokenInfoStruct = {
    tokenInfo: IHederaTokenService.TokenInfoStruct;
    decimals: BigNumberish;
  };

  export type FungibleTokenInfoStructOutput = [
    tokenInfo: IHederaTokenService.TokenInfoStructOutput,
    decimals: bigint
  ] & {
    tokenInfo: IHederaTokenService.TokenInfoStructOutput;
    decimals: bigint;
  };

  export type NonFungibleTokenInfoStruct = {
    tokenInfo: IHederaTokenService.TokenInfoStruct;
    serialNumber: BigNumberish;
    ownerId: AddressLike;
    creationTime: BigNumberish;
    metadata: BytesLike;
    spenderId: AddressLike;
  };

  export type NonFungibleTokenInfoStructOutput = [
    tokenInfo: IHederaTokenService.TokenInfoStructOutput,
    serialNumber: bigint,
    ownerId: string,
    creationTime: bigint,
    metadata: string,
    spenderId: string
  ] & {
    tokenInfo: IHederaTokenService.TokenInfoStructOutput;
    serialNumber: bigint;
    ownerId: string;
    creationTime: bigint;
    metadata: string;
    spenderId: string;
  };

  export type KeyValueStruct = {
    inheritAccountKey: boolean;
    contractId: AddressLike;
    ed25519: BytesLike;
    ECDSA_secp256k1: BytesLike;
    delegatableContractId: AddressLike;
  };

  export type KeyValueStructOutput = [
    inheritAccountKey: boolean,
    contractId: string,
    ed25519: string,
    ECDSA_secp256k1: string,
    delegatableContractId: string
  ] & {
    inheritAccountKey: boolean;
    contractId: string;
    ed25519: string;
    ECDSA_secp256k1: string;
    delegatableContractId: string;
  };

  export type NftIDStruct = { nft: AddressLike; serial: BigNumberish };

  export type NftIDStructOutput = [nft: string, serial: bigint] & {
    nft: string;
    serial: bigint;
  };

  export type TokenKeyStruct = {
    keyType: BigNumberish;
    key: IHederaTokenService.KeyValueStruct;
  };

  export type TokenKeyStructOutput = [
    keyType: bigint,
    key: IHederaTokenService.KeyValueStructOutput
  ] & { keyType: bigint; key: IHederaTokenService.KeyValueStructOutput };
}

export interface MockHederaTokenServiceInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "airdropTokens"
      | "airdropTokens((address,(address,int64,bool)[],(address,address,int64,bool)[])[])"
      | "allowance"
      | "allowance(address,address,address)"
      | "approve"
      | "approve(address,address,uint256)"
      | "approveNFT"
      | "approveNFT(address,address,uint256)"
      | "associateToken"
      | "associateToken(address,address)"
      | "associateTokens"
      | "associateTokens(address,address[])"
      | "burnToken"
      | "burnToken(address,int64,int64[])"
      | "cancelAirdrops"
      | "cancelAirdrops((address,address,address,int64)[])"
      | "claimAirdrops"
      | "claimAirdrops((address,address,address,int64)[])"
      | "createFungibleToken"
      | "createFungibleToken((string,string,address,string,bool,int64,bool,(int64,address,int64)),int64,int32)"
      | "createFungibleTokenWithCustomFees"
      | "createFungibleTokenWithCustomFees((string,string,address,string,bool,int64,bool,(int64,address,int64)),int64,int32,(int64,address,bool,bool,address)[],(int64,int64,int64,int64,bool,address)[])"
      | "createNonFungibleToken"
      | "createNonFungibleToken((string,string,address,string,bool,int64,bool,(int64,address,int64)))"
      | "createNonFungibleTokenWithCustomFees"
      | "createNonFungibleTokenWithCustomFees((string,string,address,string,bool,int64,bool,(int64,address,int64)),(int64,address,bool,bool,address)[],(int64,int64,int64,address,bool,address)[])"
      | "cryptoTransfer"
      | "cryptoTransfer(((address,int64,bool)[]),(address,(address,int64,bool)[],(address,address,int64,bool)[])[])"
      | "deleteToken"
      | "deleteToken(address)"
      | "dissociateToken"
      | "dissociateToken(address,address)"
      | "dissociateTokens"
      | "dissociateTokens(address,address[])"
      | "freezeToken"
      | "freezeToken(address,address)"
      | "getApproved"
      | "getApproved(address,uint256)"
      | "getFungibleTokenInfo"
      | "getFungibleTokenInfo(address)"
      | "getNonFungibleTokenInfo"
      | "getNonFungibleTokenInfo(address,int64)"
      | "getTokenCustomFees"
      | "getTokenCustomFees(address)"
      | "getTokenDefaultFreezeStatus"
      | "getTokenDefaultFreezeStatus(address)"
      | "getTokenDefaultKycStatus"
      | "getTokenDefaultKycStatus(address)"
      | "getTokenExpiryInfo"
      | "getTokenExpiryInfo(address)"
      | "getTokenInfo"
      | "getTokenInfo(address)"
      | "getTokenKey"
      | "getTokenKey(address,uint256)"
      | "getTokenType"
      | "getTokenType(address)"
      | "grantTokenKyc"
      | "grantTokenKyc(address,address)"
      | "isApprovedForAll"
      | "isApprovedForAll(address,address,address)"
      | "isFrozen"
      | "isFrozen(address,address)"
      | "isKyc"
      | "isKyc(address,address)"
      | "isToken"
      | "isToken(address)"
      | "mintToken"
      | "mintToken(address,int64,bytes[])"
      | "pauseToken"
      | "pauseToken(address)"
      | "redirectForToken"
      | "redirectForToken(address,bytes)"
      | "rejectTokens"
      | "rejectTokens(address,address[],(address,int64)[])"
      | "revokeTokenKyc"
      | "revokeTokenKyc(address,address)"
      | "setApprovalForAll"
      | "setApprovalForAll(address,address,bool)"
      | "setMockedCreateTokenResponse"
      | "setMockedCreateTokenResponse(int64,address)"
      | "setSupplyKeyHolder"
      | "setSupplyKeyHolder(address,address)"
      | "setTokenAssociation"
      | "setTokenAssociation(address,address,bool)"
      | "setupTokens"
      | "setupTokens(address,address,address,address)"
      | "transferFrom"
      | "transferFrom(address,address,address,uint256)"
      | "transferFromNFT"
      | "transferFromNFT(address,address,address,uint256)"
      | "transferNFT"
      | "transferNFT(address,address,address,int64)"
      | "transferNFTs"
      | "transferNFTs(address,address[],address[],int64[])"
      | "transferToken"
      | "transferToken(address,address,address,int64)"
      | "transferTokens"
      | "transferTokens(address,address[],int64[])"
      | "unfreezeToken"
      | "unfreezeToken(address,address)"
      | "unpauseToken"
      | "unpauseToken(address)"
      | "updateFungibleTokenCustomFees"
      | "updateFungibleTokenCustomFees(address,(int64,address,bool,bool,address)[],(int64,int64,int64,int64,bool,address)[])"
      | "updateNonFungibleTokenCustomFees"
      | "updateNonFungibleTokenCustomFees(address,(int64,address,bool,bool,address)[],(int64,int64,int64,address,bool,address)[])"
      | "updateTokenExpiryInfo"
      | "updateTokenExpiryInfo(address,(int64,address,int64))"
      | "updateTokenInfo"
      | "updateTokenInfo(address,(string,string,address,string,bool,int64,bool,(int64,address,int64)))"
      | "updateTokenKeys"
      | "updateTokenKeys(address,(uint256,(bool,address,bytes,bytes,address))[])"
      | "wipeTokenAccount"
      | "wipeTokenAccount(address,address,int64)"
      | "wipeTokenAccountNFT"
      | "wipeTokenAccountNFT(address,address,int64[])"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "TokenAssociated"
      | "TokenAssociated(address,address,int64)"
      | "TokenCreated"
      | "TokenCreated(address,int64)"
      | "TokenMinted"
      | "TokenMinted(address,uint256,int64)"
      | "TokenTransferred"
      | "TokenTransferred(address,address,address,uint256,int64)"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "airdropTokens",
    values: [IHederaTokenService.TokenTransferListStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "airdropTokens((address,(address,int64,bool)[],(address,address,int64,bool)[])[])",
    values: [IHederaTokenService.TokenTransferListStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "allowance",
    values: [AddressLike, AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "allowance(address,address,address)",
    values: [AddressLike, AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "approve(address,address,uint256)",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "approveNFT",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "approveNFT(address,address,uint256)",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "associateToken",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "associateToken(address,address)",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "associateTokens",
    values: [AddressLike, AddressLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "associateTokens(address,address[])",
    values: [AddressLike, AddressLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "burnToken",
    values: [AddressLike, BigNumberish, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "burnToken(address,int64,int64[])",
    values: [AddressLike, BigNumberish, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelAirdrops",
    values: [IHederaTokenService.PendingAirdropStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelAirdrops((address,address,address,int64)[])",
    values: [IHederaTokenService.PendingAirdropStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "claimAirdrops",
    values: [IHederaTokenService.PendingAirdropStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "claimAirdrops((address,address,address,int64)[])",
    values: [IHederaTokenService.PendingAirdropStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "createFungibleToken",
    values: [IHederaTokenService.HederaTokenStruct, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createFungibleToken((string,string,address,string,bool,int64,bool,(int64,address,int64)),int64,int32)",
    values: [IHederaTokenService.HederaTokenStruct, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createFungibleTokenWithCustomFees",
    values: [
      IHederaTokenService.HederaTokenStruct,
      BigNumberish,
      BigNumberish,
      IHederaTokenService.FixedFeeStruct[],
      IHederaTokenService.FractionalFeeStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createFungibleTokenWithCustomFees((string,string,address,string,bool,int64,bool,(int64,address,int64)),int64,int32,(int64,address,bool,bool,address)[],(int64,int64,int64,int64,bool,address)[])",
    values: [
      IHederaTokenService.HederaTokenStruct,
      BigNumberish,
      BigNumberish,
      IHederaTokenService.FixedFeeStruct[],
      IHederaTokenService.FractionalFeeStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createNonFungibleToken",
    values: [IHederaTokenService.HederaTokenStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "createNonFungibleToken((string,string,address,string,bool,int64,bool,(int64,address,int64)))",
    values: [IHederaTokenService.HederaTokenStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "createNonFungibleTokenWithCustomFees",
    values: [
      IHederaTokenService.HederaTokenStruct,
      IHederaTokenService.FixedFeeStruct[],
      IHederaTokenService.RoyaltyFeeStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createNonFungibleTokenWithCustomFees((string,string,address,string,bool,int64,bool,(int64,address,int64)),(int64,address,bool,bool,address)[],(int64,int64,int64,address,bool,address)[])",
    values: [
      IHederaTokenService.HederaTokenStruct,
      IHederaTokenService.FixedFeeStruct[],
      IHederaTokenService.RoyaltyFeeStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cryptoTransfer",
    values: [
      IHederaTokenService.TransferListStruct,
      IHederaTokenService.TokenTransferListStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cryptoTransfer(((address,int64,bool)[]),(address,(address,int64,bool)[],(address,address,int64,bool)[])[])",
    values: [
      IHederaTokenService.TransferListStruct,
      IHederaTokenService.TokenTransferListStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deleteToken",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "deleteToken(address)",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "dissociateToken",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "dissociateToken(address,address)",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "dissociateTokens",
    values: [AddressLike, AddressLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "dissociateTokens(address,address[])",
    values: [AddressLike, AddressLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "freezeToken",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "freezeToken(address,address)",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getApproved",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getApproved(address,uint256)",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getFungibleTokenInfo",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getFungibleTokenInfo(address)",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getNonFungibleTokenInfo",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getNonFungibleTokenInfo(address,int64)",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenCustomFees",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenCustomFees(address)",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenDefaultFreezeStatus",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenDefaultFreezeStatus(address)",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenDefaultKycStatus",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenDefaultKycStatus(address)",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenExpiryInfo",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenExpiryInfo(address)",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenInfo",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenInfo(address)",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenKey",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenKey(address,uint256)",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenType",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenType(address)",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "grantTokenKyc",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "grantTokenKyc(address,address)",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [AddressLike, AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll(address,address,address)",
    values: [AddressLike, AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isFrozen",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isFrozen(address,address)",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isKyc",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isKyc(address,address)",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isToken",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isToken(address)",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "mintToken",
    values: [AddressLike, BigNumberish, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "mintToken(address,int64,bytes[])",
    values: [AddressLike, BigNumberish, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "pauseToken",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "pauseToken(address)",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "redirectForToken",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "redirectForToken(address,bytes)",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "rejectTokens",
    values: [AddressLike, AddressLike[], IHederaTokenService.NftIDStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "rejectTokens(address,address[],(address,int64)[])",
    values: [AddressLike, AddressLike[], IHederaTokenService.NftIDStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "revokeTokenKyc",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "revokeTokenKyc(address,address)",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll",
    values: [AddressLike, AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll(address,address,bool)",
    values: [AddressLike, AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setMockedCreateTokenResponse",
    values: [BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setMockedCreateTokenResponse(int64,address)",
    values: [BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setSupplyKeyHolder",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setSupplyKeyHolder(address,address)",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setTokenAssociation",
    values: [AddressLike, AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setTokenAssociation(address,address,bool)",
    values: [AddressLike, AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setupTokens",
    values: [AddressLike, AddressLike, AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setupTokens(address,address,address,address)",
    values: [AddressLike, AddressLike, AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom(address,address,address,uint256)",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFromNFT",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFromNFT(address,address,address,uint256)",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferNFT",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferNFT(address,address,address,int64)",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferNFTs",
    values: [AddressLike, AddressLike[], AddressLike[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "transferNFTs(address,address[],address[],int64[])",
    values: [AddressLike, AddressLike[], AddressLike[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "transferToken",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferToken(address,address,address,int64)",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferTokens",
    values: [AddressLike, AddressLike[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "transferTokens(address,address[],int64[])",
    values: [AddressLike, AddressLike[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "unfreezeToken",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "unfreezeToken(address,address)",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "unpauseToken",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "unpauseToken(address)",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "updateFungibleTokenCustomFees",
    values: [
      AddressLike,
      IHederaTokenService.FixedFeeStruct[],
      IHederaTokenService.FractionalFeeStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateFungibleTokenCustomFees(address,(int64,address,bool,bool,address)[],(int64,int64,int64,int64,bool,address)[])",
    values: [
      AddressLike,
      IHederaTokenService.FixedFeeStruct[],
      IHederaTokenService.FractionalFeeStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateNonFungibleTokenCustomFees",
    values: [
      AddressLike,
      IHederaTokenService.FixedFeeStruct[],
      IHederaTokenService.RoyaltyFeeStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateNonFungibleTokenCustomFees(address,(int64,address,bool,bool,address)[],(int64,int64,int64,address,bool,address)[])",
    values: [
      AddressLike,
      IHederaTokenService.FixedFeeStruct[],
      IHederaTokenService.RoyaltyFeeStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenExpiryInfo",
    values: [AddressLike, IHederaTokenService.ExpiryStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenExpiryInfo(address,(int64,address,int64))",
    values: [AddressLike, IHederaTokenService.ExpiryStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenInfo",
    values: [AddressLike, IHederaTokenService.HederaTokenStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenInfo(address,(string,string,address,string,bool,int64,bool,(int64,address,int64)))",
    values: [AddressLike, IHederaTokenService.HederaTokenStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenKeys",
    values: [AddressLike, IHederaTokenService.TokenKeyStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenKeys(address,(uint256,(bool,address,bytes,bytes,address))[])",
    values: [AddressLike, IHederaTokenService.TokenKeyStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "wipeTokenAccount",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "wipeTokenAccount(address,address,int64)",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "wipeTokenAccountNFT",
    values: [AddressLike, AddressLike, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "wipeTokenAccountNFT(address,address,int64[])",
    values: [AddressLike, AddressLike, BigNumberish[]]
  ): string;

  decodeFunctionResult(
    functionFragment: "airdropTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "airdropTokens((address,(address,int64,bool)[],(address,address,int64,bool)[])[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "allowance(address,address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "approve(address,address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "approveNFT", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "approveNFT(address,address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "associateToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "associateToken(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "associateTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "associateTokens(address,address[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "burnToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "burnToken(address,int64,int64[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelAirdrops",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelAirdrops((address,address,address,int64)[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimAirdrops",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimAirdrops((address,address,address,int64)[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createFungibleToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createFungibleToken((string,string,address,string,bool,int64,bool,(int64,address,int64)),int64,int32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createFungibleTokenWithCustomFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createFungibleTokenWithCustomFees((string,string,address,string,bool,int64,bool,(int64,address,int64)),int64,int32,(int64,address,bool,bool,address)[],(int64,int64,int64,int64,bool,address)[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createNonFungibleToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createNonFungibleToken((string,string,address,string,bool,int64,bool,(int64,address,int64)))",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createNonFungibleTokenWithCustomFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createNonFungibleTokenWithCustomFees((string,string,address,string,bool,int64,bool,(int64,address,int64)),(int64,address,bool,bool,address)[],(int64,int64,int64,address,bool,address)[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cryptoTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cryptoTransfer(((address,int64,bool)[]),(address,(address,int64,bool)[],(address,address,int64,bool)[])[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deleteToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deleteToken(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dissociateToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dissociateToken(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dissociateTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dissociateTokens(address,address[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "freezeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "freezeToken(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getApproved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getApproved(address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFungibleTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFungibleTokenInfo(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNonFungibleTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNonFungibleTokenInfo(address,int64)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenCustomFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenCustomFees(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenDefaultFreezeStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenDefaultFreezeStatus(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenDefaultKycStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenDefaultKycStatus(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenExpiryInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenExpiryInfo(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenInfo(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenKey",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenKey(address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenType",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenType(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "grantTokenKyc",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "grantTokenKyc(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll(address,address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isFrozen", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isFrozen(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isKyc", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isKyc(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isToken(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mintToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "mintToken(address,int64,bytes[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pauseToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pauseToken(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redirectForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redirectForToken(address,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rejectTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rejectTokens(address,address[],(address,int64)[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revokeTokenKyc",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revokeTokenKyc(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll(address,address,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMockedCreateTokenResponse",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMockedCreateTokenResponse(int64,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSupplyKeyHolder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSupplyKeyHolder(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTokenAssociation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTokenAssociation(address,address,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setupTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setupTokens(address,address,address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom(address,address,address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFromNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFromNFT(address,address,address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferNFT(address,address,address,int64)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferNFTs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferNFTs(address,address[],address[],int64[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferToken(address,address,address,int64)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferTokens(address,address[],int64[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unfreezeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unfreezeToken(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unpauseToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unpauseToken(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateFungibleTokenCustomFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateFungibleTokenCustomFees(address,(int64,address,bool,bool,address)[],(int64,int64,int64,int64,bool,address)[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateNonFungibleTokenCustomFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateNonFungibleTokenCustomFees(address,(int64,address,bool,bool,address)[],(int64,int64,int64,address,bool,address)[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenExpiryInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenExpiryInfo(address,(int64,address,int64))",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenInfo(address,(string,string,address,string,bool,int64,bool,(int64,address,int64)))",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenKeys",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenKeys(address,(uint256,(bool,address,bytes,bytes,address))[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "wipeTokenAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "wipeTokenAccount(address,address,int64)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "wipeTokenAccountNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "wipeTokenAccountNFT(address,address,int64[])",
    data: BytesLike
  ): Result;
}

export namespace TokenAssociatedEvent {
  export type InputTuple = [
    token: AddressLike,
    account: AddressLike,
    responseCode: BigNumberish
  ];
  export type OutputTuple = [
    token: string,
    account: string,
    responseCode: bigint
  ];
  export interface OutputObject {
    token: string;
    account: string;
    responseCode: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TokenCreatedEvent {
  export type InputTuple = [
    tokenAddress: AddressLike,
    responseCode: BigNumberish
  ];
  export type OutputTuple = [tokenAddress: string, responseCode: bigint];
  export interface OutputObject {
    tokenAddress: string;
    responseCode: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TokenMintedEvent {
  export type InputTuple = [
    token: AddressLike,
    amount: BigNumberish,
    responseCode: BigNumberish
  ];
  export type OutputTuple = [
    token: string,
    amount: bigint,
    responseCode: bigint
  ];
  export interface OutputObject {
    token: string;
    amount: bigint;
    responseCode: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TokenTransferredEvent {
  export type InputTuple = [
    token: AddressLike,
    from: AddressLike,
    to: AddressLike,
    amount: BigNumberish,
    responseCode: BigNumberish
  ];
  export type OutputTuple = [
    token: string,
    from: string,
    to: string,
    amount: bigint,
    responseCode: bigint
  ];
  export interface OutputObject {
    token: string;
    from: string;
    to: string;
    amount: bigint;
    responseCode: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface MockHederaTokenService extends BaseContract {
  contractName: "MockHederaTokenService";

  connect(runner?: ContractRunner | null): MockHederaTokenService;
  waitForDeployment(): Promise<this>;

  interface: MockHederaTokenServiceInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  airdropTokens: TypedContractMethod<
    [arg0: IHederaTokenService.TokenTransferListStruct[]],
    [bigint],
    "nonpayable"
  >;

  "airdropTokens((address,(address,int64,bool)[],(address,address,int64,bool)[])[])": TypedContractMethod<
    [arg0: IHederaTokenService.TokenTransferListStruct[]],
    [bigint],
    "nonpayable"
  >;

  allowance: TypedContractMethod<
    [token: AddressLike, owner: AddressLike, spender: AddressLike],
    [[bigint, bigint] & { responseCode: bigint; allowanceAmount: bigint }],
    "nonpayable"
  >;

  "allowance(address,address,address)": TypedContractMethod<
    [token: AddressLike, owner: AddressLike, spender: AddressLike],
    [[bigint, bigint] & { responseCode: bigint; allowanceAmount: bigint }],
    "nonpayable"
  >;

  approve: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  "approve(address,address,uint256)": TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  approveNFT: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  "approveNFT(address,address,uint256)": TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  associateToken: TypedContractMethod<
    [account: AddressLike, token: AddressLike],
    [bigint],
    "nonpayable"
  >;

  "associateToken(address,address)": TypedContractMethod<
    [account: AddressLike, token: AddressLike],
    [bigint],
    "nonpayable"
  >;

  associateTokens: TypedContractMethod<
    [account: AddressLike, tokens: AddressLike[]],
    [bigint],
    "nonpayable"
  >;

  "associateTokens(address,address[])": TypedContractMethod<
    [account: AddressLike, tokens: AddressLike[]],
    [bigint],
    "nonpayable"
  >;

  burnToken: TypedContractMethod<
    [token: AddressLike, amount: BigNumberish, serialNumbers: BigNumberish[]],
    [[bigint, bigint] & { responseCode: bigint; newTotalSupply: bigint }],
    "nonpayable"
  >;

  "burnToken(address,int64,int64[])": TypedContractMethod<
    [token: AddressLike, amount: BigNumberish, serialNumbers: BigNumberish[]],
    [[bigint, bigint] & { responseCode: bigint; newTotalSupply: bigint }],
    "nonpayable"
  >;

  cancelAirdrops: TypedContractMethod<
    [arg0: IHederaTokenService.PendingAirdropStruct[]],
    [bigint],
    "nonpayable"
  >;

  "cancelAirdrops((address,address,address,int64)[])": TypedContractMethod<
    [arg0: IHederaTokenService.PendingAirdropStruct[]],
    [bigint],
    "nonpayable"
  >;

  claimAirdrops: TypedContractMethod<
    [arg0: IHederaTokenService.PendingAirdropStruct[]],
    [bigint],
    "nonpayable"
  >;

  "claimAirdrops((address,address,address,int64)[])": TypedContractMethod<
    [arg0: IHederaTokenService.PendingAirdropStruct[]],
    [bigint],
    "nonpayable"
  >;

  createFungibleToken: TypedContractMethod<
    [
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish
    ],
    [[bigint, string] & { responseCode: bigint; tokenAddress: string }],
    "payable"
  >;

  "createFungibleToken((string,string,address,string,bool,int64,bool,(int64,address,int64)),int64,int32)": TypedContractMethod<
    [
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish
    ],
    [[bigint, string] & { responseCode: bigint; tokenAddress: string }],
    "payable"
  >;

  createFungibleTokenWithCustomFees: TypedContractMethod<
    [
      arg0: IHederaTokenService.HederaTokenStruct,
      arg1: BigNumberish,
      arg2: BigNumberish,
      arg3: IHederaTokenService.FixedFeeStruct[],
      arg4: IHederaTokenService.FractionalFeeStruct[]
    ],
    [[bigint, string]],
    "payable"
  >;

  "createFungibleTokenWithCustomFees((string,string,address,string,bool,int64,bool,(int64,address,int64)),int64,int32,(int64,address,bool,bool,address)[],(int64,int64,int64,int64,bool,address)[])": TypedContractMethod<
    [
      arg0: IHederaTokenService.HederaTokenStruct,
      arg1: BigNumberish,
      arg2: BigNumberish,
      arg3: IHederaTokenService.FixedFeeStruct[],
      arg4: IHederaTokenService.FractionalFeeStruct[]
    ],
    [[bigint, string]],
    "payable"
  >;

  createNonFungibleToken: TypedContractMethod<
    [arg0: IHederaTokenService.HederaTokenStruct],
    [[bigint, string]],
    "payable"
  >;

  "createNonFungibleToken((string,string,address,string,bool,int64,bool,(int64,address,int64)))": TypedContractMethod<
    [arg0: IHederaTokenService.HederaTokenStruct],
    [[bigint, string]],
    "payable"
  >;

  createNonFungibleTokenWithCustomFees: TypedContractMethod<
    [
      arg0: IHederaTokenService.HederaTokenStruct,
      arg1: IHederaTokenService.FixedFeeStruct[],
      arg2: IHederaTokenService.RoyaltyFeeStruct[]
    ],
    [[bigint, string]],
    "payable"
  >;

  "createNonFungibleTokenWithCustomFees((string,string,address,string,bool,int64,bool,(int64,address,int64)),(int64,address,bool,bool,address)[],(int64,int64,int64,address,bool,address)[])": TypedContractMethod<
    [
      arg0: IHederaTokenService.HederaTokenStruct,
      arg1: IHederaTokenService.FixedFeeStruct[],
      arg2: IHederaTokenService.RoyaltyFeeStruct[]
    ],
    [[bigint, string]],
    "payable"
  >;

  cryptoTransfer: TypedContractMethod<
    [
      arg0: IHederaTokenService.TransferListStruct,
      arg1: IHederaTokenService.TokenTransferListStruct[]
    ],
    [bigint],
    "nonpayable"
  >;

  "cryptoTransfer(((address,int64,bool)[]),(address,(address,int64,bool)[],(address,address,int64,bool)[])[])": TypedContractMethod<
    [
      arg0: IHederaTokenService.TransferListStruct,
      arg1: IHederaTokenService.TokenTransferListStruct[]
    ],
    [bigint],
    "nonpayable"
  >;

  deleteToken: TypedContractMethod<[arg0: AddressLike], [bigint], "nonpayable">;

  "deleteToken(address)": TypedContractMethod<
    [arg0: AddressLike],
    [bigint],
    "nonpayable"
  >;

  dissociateToken: TypedContractMethod<
    [account: AddressLike, token: AddressLike],
    [bigint],
    "nonpayable"
  >;

  "dissociateToken(address,address)": TypedContractMethod<
    [account: AddressLike, token: AddressLike],
    [bigint],
    "nonpayable"
  >;

  dissociateTokens: TypedContractMethod<
    [account: AddressLike, tokens: AddressLike[]],
    [bigint],
    "nonpayable"
  >;

  "dissociateTokens(address,address[])": TypedContractMethod<
    [account: AddressLike, tokens: AddressLike[]],
    [bigint],
    "nonpayable"
  >;

  freezeToken: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;

  "freezeToken(address,address)": TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;

  getApproved: TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [[bigint, string]],
    "nonpayable"
  >;

  "getApproved(address,uint256)": TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [[bigint, string]],
    "nonpayable"
  >;

  getFungibleTokenInfo: TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, IHederaTokenService.FungibleTokenInfoStructOutput]],
    "nonpayable"
  >;

  "getFungibleTokenInfo(address)": TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, IHederaTokenService.FungibleTokenInfoStructOutput]],
    "nonpayable"
  >;

  getNonFungibleTokenInfo: TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [[bigint, IHederaTokenService.NonFungibleTokenInfoStructOutput]],
    "nonpayable"
  >;

  "getNonFungibleTokenInfo(address,int64)": TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [[bigint, IHederaTokenService.NonFungibleTokenInfoStructOutput]],
    "nonpayable"
  >;

  getTokenCustomFees: TypedContractMethod<
    [arg0: AddressLike],
    [
      [
        bigint,
        IHederaTokenService.FixedFeeStructOutput[],
        IHederaTokenService.FractionalFeeStructOutput[],
        IHederaTokenService.RoyaltyFeeStructOutput[]
      ]
    ],
    "nonpayable"
  >;

  "getTokenCustomFees(address)": TypedContractMethod<
    [arg0: AddressLike],
    [
      [
        bigint,
        IHederaTokenService.FixedFeeStructOutput[],
        IHederaTokenService.FractionalFeeStructOutput[],
        IHederaTokenService.RoyaltyFeeStructOutput[]
      ]
    ],
    "nonpayable"
  >;

  getTokenDefaultFreezeStatus: TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;

  "getTokenDefaultFreezeStatus(address)": TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;

  getTokenDefaultKycStatus: TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;

  "getTokenDefaultKycStatus(address)": TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;

  getTokenExpiryInfo: TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, IHederaTokenService.ExpiryStructOutput]],
    "nonpayable"
  >;

  "getTokenExpiryInfo(address)": TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, IHederaTokenService.ExpiryStructOutput]],
    "nonpayable"
  >;

  getTokenInfo: TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, IHederaTokenService.TokenInfoStructOutput]],
    "nonpayable"
  >;

  "getTokenInfo(address)": TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, IHederaTokenService.TokenInfoStructOutput]],
    "nonpayable"
  >;

  getTokenKey: TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [[bigint, IHederaTokenService.KeyValueStructOutput]],
    "nonpayable"
  >;

  "getTokenKey(address,uint256)": TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [[bigint, IHederaTokenService.KeyValueStructOutput]],
    "nonpayable"
  >;

  getTokenType: TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, bigint]],
    "nonpayable"
  >;

  "getTokenType(address)": TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, bigint]],
    "nonpayable"
  >;

  grantTokenKyc: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;

  "grantTokenKyc(address,address)": TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;

  isApprovedForAll: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;

  "isApprovedForAll(address,address,address)": TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;

  isFrozen: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;

  "isFrozen(address,address)": TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;

  isKyc: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;

  "isKyc(address,address)": TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;

  isToken: TypedContractMethod<
    [token: AddressLike],
    [[bigint, boolean] & { responseCode: bigint; isTokenFlag: boolean }],
    "nonpayable"
  >;

  "isToken(address)": TypedContractMethod<
    [token: AddressLike],
    [[bigint, boolean] & { responseCode: bigint; isTokenFlag: boolean }],
    "nonpayable"
  >;

  mintToken: TypedContractMethod<
    [token: AddressLike, amount: BigNumberish, metadata: BytesLike[]],
    [
      [bigint, bigint, bigint[]] & {
        responseCode: bigint;
        newTotalSupply: bigint;
        serialNumbers: bigint[];
      }
    ],
    "nonpayable"
  >;

  "mintToken(address,int64,bytes[])": TypedContractMethod<
    [token: AddressLike, amount: BigNumberish, metadata: BytesLike[]],
    [
      [bigint, bigint, bigint[]] & {
        responseCode: bigint;
        newTotalSupply: bigint;
        serialNumbers: bigint[];
      }
    ],
    "nonpayable"
  >;

  pauseToken: TypedContractMethod<[arg0: AddressLike], [bigint], "nonpayable">;

  "pauseToken(address)": TypedContractMethod<
    [arg0: AddressLike],
    [bigint],
    "nonpayable"
  >;

  redirectForToken: TypedContractMethod<
    [arg0: AddressLike, arg1: BytesLike],
    [[bigint, string]],
    "nonpayable"
  >;

  "redirectForToken(address,bytes)": TypedContractMethod<
    [arg0: AddressLike, arg1: BytesLike],
    [[bigint, string]],
    "nonpayable"
  >;

  rejectTokens: TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike[],
      arg2: IHederaTokenService.NftIDStruct[]
    ],
    [bigint],
    "nonpayable"
  >;

  "rejectTokens(address,address[],(address,int64)[])": TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike[],
      arg2: IHederaTokenService.NftIDStruct[]
    ],
    [bigint],
    "nonpayable"
  >;

  revokeTokenKyc: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;

  "revokeTokenKyc(address,address)": TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;

  setApprovalForAll: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: boolean],
    [bigint],
    "nonpayable"
  >;

  "setApprovalForAll(address,address,bool)": TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: boolean],
    [bigint],
    "nonpayable"
  >;

  setMockedCreateTokenResponse: TypedContractMethod<
    [responseCode: BigNumberish, tokenAddress: AddressLike],
    [void],
    "nonpayable"
  >;

  "setMockedCreateTokenResponse(int64,address)": TypedContractMethod<
    [responseCode: BigNumberish, tokenAddress: AddressLike],
    [void],
    "nonpayable"
  >;

  setSupplyKeyHolder: TypedContractMethod<
    [token: AddressLike, holder: AddressLike],
    [void],
    "nonpayable"
  >;

  "setSupplyKeyHolder(address,address)": TypedContractMethod<
    [token: AddressLike, holder: AddressLike],
    [void],
    "nonpayable"
  >;

  setTokenAssociation: TypedContractMethod<
    [token: AddressLike, account: AddressLike, isAssociated: boolean],
    [void],
    "nonpayable"
  >;

  "setTokenAssociation(address,address,bool)": TypedContractMethod<
    [token: AddressLike, account: AddressLike, isAssociated: boolean],
    [void],
    "nonpayable"
  >;

  setupTokens: TypedContractMethod<
    [
      tokenAddress: AddressLike,
      sauceTokenAddress: AddressLike,
      clxyTokenAddress: AddressLike,
      userAddress: AddressLike
    ],
    [void],
    "nonpayable"
  >;

  "setupTokens(address,address,address,address)": TypedContractMethod<
    [
      tokenAddress: AddressLike,
      sauceTokenAddress: AddressLike,
      clxyTokenAddress: AddressLike,
      userAddress: AddressLike
    ],
    [void],
    "nonpayable"
  >;

  transferFrom: TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: AddressLike,
      arg3: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  "transferFrom(address,address,address,uint256)": TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: AddressLike,
      arg3: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  transferFromNFT: TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: AddressLike,
      arg3: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  "transferFromNFT(address,address,address,uint256)": TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: AddressLike,
      arg3: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  transferNFT: TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: AddressLike,
      arg3: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  "transferNFT(address,address,address,int64)": TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: AddressLike,
      arg3: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  transferNFTs: TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike[],
      arg2: AddressLike[],
      arg3: BigNumberish[]
    ],
    [bigint],
    "nonpayable"
  >;

  "transferNFTs(address,address[],address[],int64[])": TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike[],
      arg2: AddressLike[],
      arg3: BigNumberish[]
    ],
    [bigint],
    "nonpayable"
  >;

  transferToken: TypedContractMethod<
    [
      token: AddressLike,
      sender: AddressLike,
      recipient: AddressLike,
      amount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  "transferToken(address,address,address,int64)": TypedContractMethod<
    [
      token: AddressLike,
      sender: AddressLike,
      recipient: AddressLike,
      amount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  transferTokens: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike[], arg2: BigNumberish[]],
    [bigint],
    "nonpayable"
  >;

  "transferTokens(address,address[],int64[])": TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike[], arg2: BigNumberish[]],
    [bigint],
    "nonpayable"
  >;

  unfreezeToken: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;

  "unfreezeToken(address,address)": TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;

  unpauseToken: TypedContractMethod<
    [arg0: AddressLike],
    [bigint],
    "nonpayable"
  >;

  "unpauseToken(address)": TypedContractMethod<
    [arg0: AddressLike],
    [bigint],
    "nonpayable"
  >;

  updateFungibleTokenCustomFees: TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: IHederaTokenService.FixedFeeStruct[],
      arg2: IHederaTokenService.FractionalFeeStruct[]
    ],
    [bigint],
    "nonpayable"
  >;

  "updateFungibleTokenCustomFees(address,(int64,address,bool,bool,address)[],(int64,int64,int64,int64,bool,address)[])": TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: IHederaTokenService.FixedFeeStruct[],
      arg2: IHederaTokenService.FractionalFeeStruct[]
    ],
    [bigint],
    "nonpayable"
  >;

  updateNonFungibleTokenCustomFees: TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: IHederaTokenService.FixedFeeStruct[],
      arg2: IHederaTokenService.RoyaltyFeeStruct[]
    ],
    [bigint],
    "nonpayable"
  >;

  "updateNonFungibleTokenCustomFees(address,(int64,address,bool,bool,address)[],(int64,int64,int64,address,bool,address)[])": TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: IHederaTokenService.FixedFeeStruct[],
      arg2: IHederaTokenService.RoyaltyFeeStruct[]
    ],
    [bigint],
    "nonpayable"
  >;

  updateTokenExpiryInfo: TypedContractMethod<
    [arg0: AddressLike, arg1: IHederaTokenService.ExpiryStruct],
    [bigint],
    "nonpayable"
  >;

  "updateTokenExpiryInfo(address,(int64,address,int64))": TypedContractMethod<
    [arg0: AddressLike, arg1: IHederaTokenService.ExpiryStruct],
    [bigint],
    "nonpayable"
  >;

  updateTokenInfo: TypedContractMethod<
    [arg0: AddressLike, arg1: IHederaTokenService.HederaTokenStruct],
    [bigint],
    "nonpayable"
  >;

  "updateTokenInfo(address,(string,string,address,string,bool,int64,bool,(int64,address,int64)))": TypedContractMethod<
    [arg0: AddressLike, arg1: IHederaTokenService.HederaTokenStruct],
    [bigint],
    "nonpayable"
  >;

  updateTokenKeys: TypedContractMethod<
    [arg0: AddressLike, arg1: IHederaTokenService.TokenKeyStruct[]],
    [bigint],
    "nonpayable"
  >;

  "updateTokenKeys(address,(uint256,(bool,address,bytes,bytes,address))[])": TypedContractMethod<
    [arg0: AddressLike, arg1: IHederaTokenService.TokenKeyStruct[]],
    [bigint],
    "nonpayable"
  >;

  wipeTokenAccount: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  "wipeTokenAccount(address,address,int64)": TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  wipeTokenAccountNFT: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish[]],
    [bigint],
    "nonpayable"
  >;

  "wipeTokenAccountNFT(address,address,int64[])": TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish[]],
    [bigint],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "airdropTokens"
  ): TypedContractMethod<
    [arg0: IHederaTokenService.TokenTransferListStruct[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "airdropTokens((address,(address,int64,bool)[],(address,address,int64,bool)[])[])"
  ): TypedContractMethod<
    [arg0: IHederaTokenService.TokenTransferListStruct[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "allowance"
  ): TypedContractMethod<
    [token: AddressLike, owner: AddressLike, spender: AddressLike],
    [[bigint, bigint] & { responseCode: bigint; allowanceAmount: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "allowance(address,address,address)"
  ): TypedContractMethod<
    [token: AddressLike, owner: AddressLike, spender: AddressLike],
    [[bigint, bigint] & { responseCode: bigint; allowanceAmount: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "approve"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "approve(address,address,uint256)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "approveNFT"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "approveNFT(address,address,uint256)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "associateToken"
  ): TypedContractMethod<
    [account: AddressLike, token: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "associateToken(address,address)"
  ): TypedContractMethod<
    [account: AddressLike, token: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "associateTokens"
  ): TypedContractMethod<
    [account: AddressLike, tokens: AddressLike[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "associateTokens(address,address[])"
  ): TypedContractMethod<
    [account: AddressLike, tokens: AddressLike[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "burnToken"
  ): TypedContractMethod<
    [token: AddressLike, amount: BigNumberish, serialNumbers: BigNumberish[]],
    [[bigint, bigint] & { responseCode: bigint; newTotalSupply: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "burnToken(address,int64,int64[])"
  ): TypedContractMethod<
    [token: AddressLike, amount: BigNumberish, serialNumbers: BigNumberish[]],
    [[bigint, bigint] & { responseCode: bigint; newTotalSupply: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "cancelAirdrops"
  ): TypedContractMethod<
    [arg0: IHederaTokenService.PendingAirdropStruct[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "cancelAirdrops((address,address,address,int64)[])"
  ): TypedContractMethod<
    [arg0: IHederaTokenService.PendingAirdropStruct[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "claimAirdrops"
  ): TypedContractMethod<
    [arg0: IHederaTokenService.PendingAirdropStruct[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "claimAirdrops((address,address,address,int64)[])"
  ): TypedContractMethod<
    [arg0: IHederaTokenService.PendingAirdropStruct[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "createFungibleToken"
  ): TypedContractMethod<
    [
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish
    ],
    [[bigint, string] & { responseCode: bigint; tokenAddress: string }],
    "payable"
  >;
  getFunction(
    nameOrSignature: "createFungibleToken((string,string,address,string,bool,int64,bool,(int64,address,int64)),int64,int32)"
  ): TypedContractMethod<
    [
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish
    ],
    [[bigint, string] & { responseCode: bigint; tokenAddress: string }],
    "payable"
  >;
  getFunction(
    nameOrSignature: "createFungibleTokenWithCustomFees"
  ): TypedContractMethod<
    [
      arg0: IHederaTokenService.HederaTokenStruct,
      arg1: BigNumberish,
      arg2: BigNumberish,
      arg3: IHederaTokenService.FixedFeeStruct[],
      arg4: IHederaTokenService.FractionalFeeStruct[]
    ],
    [[bigint, string]],
    "payable"
  >;
  getFunction(
    nameOrSignature: "createFungibleTokenWithCustomFees((string,string,address,string,bool,int64,bool,(int64,address,int64)),int64,int32,(int64,address,bool,bool,address)[],(int64,int64,int64,int64,bool,address)[])"
  ): TypedContractMethod<
    [
      arg0: IHederaTokenService.HederaTokenStruct,
      arg1: BigNumberish,
      arg2: BigNumberish,
      arg3: IHederaTokenService.FixedFeeStruct[],
      arg4: IHederaTokenService.FractionalFeeStruct[]
    ],
    [[bigint, string]],
    "payable"
  >;
  getFunction(
    nameOrSignature: "createNonFungibleToken"
  ): TypedContractMethod<
    [arg0: IHederaTokenService.HederaTokenStruct],
    [[bigint, string]],
    "payable"
  >;
  getFunction(
    nameOrSignature: "createNonFungibleToken((string,string,address,string,bool,int64,bool,(int64,address,int64)))"
  ): TypedContractMethod<
    [arg0: IHederaTokenService.HederaTokenStruct],
    [[bigint, string]],
    "payable"
  >;
  getFunction(
    nameOrSignature: "createNonFungibleTokenWithCustomFees"
  ): TypedContractMethod<
    [
      arg0: IHederaTokenService.HederaTokenStruct,
      arg1: IHederaTokenService.FixedFeeStruct[],
      arg2: IHederaTokenService.RoyaltyFeeStruct[]
    ],
    [[bigint, string]],
    "payable"
  >;
  getFunction(
    nameOrSignature: "createNonFungibleTokenWithCustomFees((string,string,address,string,bool,int64,bool,(int64,address,int64)),(int64,address,bool,bool,address)[],(int64,int64,int64,address,bool,address)[])"
  ): TypedContractMethod<
    [
      arg0: IHederaTokenService.HederaTokenStruct,
      arg1: IHederaTokenService.FixedFeeStruct[],
      arg2: IHederaTokenService.RoyaltyFeeStruct[]
    ],
    [[bigint, string]],
    "payable"
  >;
  getFunction(
    nameOrSignature: "cryptoTransfer"
  ): TypedContractMethod<
    [
      arg0: IHederaTokenService.TransferListStruct,
      arg1: IHederaTokenService.TokenTransferListStruct[]
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "cryptoTransfer(((address,int64,bool)[]),(address,(address,int64,bool)[],(address,address,int64,bool)[])[])"
  ): TypedContractMethod<
    [
      arg0: IHederaTokenService.TransferListStruct,
      arg1: IHederaTokenService.TokenTransferListStruct[]
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "deleteToken"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "deleteToken(address)"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "dissociateToken"
  ): TypedContractMethod<
    [account: AddressLike, token: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "dissociateToken(address,address)"
  ): TypedContractMethod<
    [account: AddressLike, token: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "dissociateTokens"
  ): TypedContractMethod<
    [account: AddressLike, tokens: AddressLike[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "dissociateTokens(address,address[])"
  ): TypedContractMethod<
    [account: AddressLike, tokens: AddressLike[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "freezeToken"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "freezeToken(address,address)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getApproved"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [[bigint, string]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getApproved(address,uint256)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [[bigint, string]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getFungibleTokenInfo"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, IHederaTokenService.FungibleTokenInfoStructOutput]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getFungibleTokenInfo(address)"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, IHederaTokenService.FungibleTokenInfoStructOutput]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getNonFungibleTokenInfo"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [[bigint, IHederaTokenService.NonFungibleTokenInfoStructOutput]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getNonFungibleTokenInfo(address,int64)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [[bigint, IHederaTokenService.NonFungibleTokenInfoStructOutput]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenCustomFees"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [
      [
        bigint,
        IHederaTokenService.FixedFeeStructOutput[],
        IHederaTokenService.FractionalFeeStructOutput[],
        IHederaTokenService.RoyaltyFeeStructOutput[]
      ]
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenCustomFees(address)"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [
      [
        bigint,
        IHederaTokenService.FixedFeeStructOutput[],
        IHederaTokenService.FractionalFeeStructOutput[],
        IHederaTokenService.RoyaltyFeeStructOutput[]
      ]
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenDefaultFreezeStatus"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenDefaultFreezeStatus(address)"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenDefaultKycStatus"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenDefaultKycStatus(address)"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenExpiryInfo"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, IHederaTokenService.ExpiryStructOutput]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenExpiryInfo(address)"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, IHederaTokenService.ExpiryStructOutput]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenInfo"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, IHederaTokenService.TokenInfoStructOutput]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenInfo(address)"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, IHederaTokenService.TokenInfoStructOutput]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenKey"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [[bigint, IHederaTokenService.KeyValueStructOutput]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenKey(address,uint256)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [[bigint, IHederaTokenService.KeyValueStructOutput]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenType"
  ): TypedContractMethod<[arg0: AddressLike], [[bigint, bigint]], "nonpayable">;
  getFunction(
    nameOrSignature: "getTokenType(address)"
  ): TypedContractMethod<[arg0: AddressLike], [[bigint, bigint]], "nonpayable">;
  getFunction(
    nameOrSignature: "grantTokenKyc"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "grantTokenKyc(address,address)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isApprovedForAll"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isApprovedForAll(address,address,address)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isFrozen"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isFrozen(address,address)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isKyc"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isKyc(address,address)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [[bigint, boolean]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isToken"
  ): TypedContractMethod<
    [token: AddressLike],
    [[bigint, boolean] & { responseCode: bigint; isTokenFlag: boolean }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isToken(address)"
  ): TypedContractMethod<
    [token: AddressLike],
    [[bigint, boolean] & { responseCode: bigint; isTokenFlag: boolean }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "mintToken"
  ): TypedContractMethod<
    [token: AddressLike, amount: BigNumberish, metadata: BytesLike[]],
    [
      [bigint, bigint, bigint[]] & {
        responseCode: bigint;
        newTotalSupply: bigint;
        serialNumbers: bigint[];
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "mintToken(address,int64,bytes[])"
  ): TypedContractMethod<
    [token: AddressLike, amount: BigNumberish, metadata: BytesLike[]],
    [
      [bigint, bigint, bigint[]] & {
        responseCode: bigint;
        newTotalSupply: bigint;
        serialNumbers: bigint[];
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "pauseToken"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "pauseToken(address)"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "redirectForToken"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: BytesLike],
    [[bigint, string]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "redirectForToken(address,bytes)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: BytesLike],
    [[bigint, string]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "rejectTokens"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike[],
      arg2: IHederaTokenService.NftIDStruct[]
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "rejectTokens(address,address[],(address,int64)[])"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike[],
      arg2: IHederaTokenService.NftIDStruct[]
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "revokeTokenKyc"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "revokeTokenKyc(address,address)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setApprovalForAll"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: boolean],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setApprovalForAll(address,address,bool)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: boolean],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setMockedCreateTokenResponse"
  ): TypedContractMethod<
    [responseCode: BigNumberish, tokenAddress: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setMockedCreateTokenResponse(int64,address)"
  ): TypedContractMethod<
    [responseCode: BigNumberish, tokenAddress: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setSupplyKeyHolder"
  ): TypedContractMethod<
    [token: AddressLike, holder: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setSupplyKeyHolder(address,address)"
  ): TypedContractMethod<
    [token: AddressLike, holder: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setTokenAssociation"
  ): TypedContractMethod<
    [token: AddressLike, account: AddressLike, isAssociated: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setTokenAssociation(address,address,bool)"
  ): TypedContractMethod<
    [token: AddressLike, account: AddressLike, isAssociated: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setupTokens"
  ): TypedContractMethod<
    [
      tokenAddress: AddressLike,
      sauceTokenAddress: AddressLike,
      clxyTokenAddress: AddressLike,
      userAddress: AddressLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setupTokens(address,address,address,address)"
  ): TypedContractMethod<
    [
      tokenAddress: AddressLike,
      sauceTokenAddress: AddressLike,
      clxyTokenAddress: AddressLike,
      userAddress: AddressLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFrom"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: AddressLike,
      arg3: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFrom(address,address,address,uint256)"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: AddressLike,
      arg3: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFromNFT"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: AddressLike,
      arg3: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFromNFT(address,address,address,uint256)"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: AddressLike,
      arg3: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferNFT"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: AddressLike,
      arg3: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferNFT(address,address,address,int64)"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: AddressLike,
      arg3: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferNFTs"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike[],
      arg2: AddressLike[],
      arg3: BigNumberish[]
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferNFTs(address,address[],address[],int64[])"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike[],
      arg2: AddressLike[],
      arg3: BigNumberish[]
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferToken"
  ): TypedContractMethod<
    [
      token: AddressLike,
      sender: AddressLike,
      recipient: AddressLike,
      amount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferToken(address,address,address,int64)"
  ): TypedContractMethod<
    [
      token: AddressLike,
      sender: AddressLike,
      recipient: AddressLike,
      amount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferTokens"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike[], arg2: BigNumberish[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferTokens(address,address[],int64[])"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike[], arg2: BigNumberish[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "unfreezeToken"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "unfreezeToken(address,address)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "unpauseToken"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "unpauseToken(address)"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "updateFungibleTokenCustomFees"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: IHederaTokenService.FixedFeeStruct[],
      arg2: IHederaTokenService.FractionalFeeStruct[]
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateFungibleTokenCustomFees(address,(int64,address,bool,bool,address)[],(int64,int64,int64,int64,bool,address)[])"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: IHederaTokenService.FixedFeeStruct[],
      arg2: IHederaTokenService.FractionalFeeStruct[]
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateNonFungibleTokenCustomFees"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: IHederaTokenService.FixedFeeStruct[],
      arg2: IHederaTokenService.RoyaltyFeeStruct[]
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateNonFungibleTokenCustomFees(address,(int64,address,bool,bool,address)[],(int64,int64,int64,address,bool,address)[])"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: IHederaTokenService.FixedFeeStruct[],
      arg2: IHederaTokenService.RoyaltyFeeStruct[]
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateTokenExpiryInfo"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: IHederaTokenService.ExpiryStruct],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateTokenExpiryInfo(address,(int64,address,int64))"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: IHederaTokenService.ExpiryStruct],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateTokenInfo"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: IHederaTokenService.HederaTokenStruct],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateTokenInfo(address,(string,string,address,string,bool,int64,bool,(int64,address,int64)))"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: IHederaTokenService.HederaTokenStruct],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateTokenKeys"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: IHederaTokenService.TokenKeyStruct[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateTokenKeys(address,(uint256,(bool,address,bytes,bytes,address))[])"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: IHederaTokenService.TokenKeyStruct[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "wipeTokenAccount"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "wipeTokenAccount(address,address,int64)"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "wipeTokenAccountNFT"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "wipeTokenAccountNFT(address,address,int64[])"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish[]],
    [bigint],
    "nonpayable"
  >;

  getEvent(
    key: "TokenAssociated"
  ): TypedContractEvent<
    TokenAssociatedEvent.InputTuple,
    TokenAssociatedEvent.OutputTuple,
    TokenAssociatedEvent.OutputObject
  >;
  getEvent(
    key: "TokenAssociated(address,address,int64)"
  ): TypedContractEvent<
    TokenAssociated_address_address_int64_Event.InputTuple,
    TokenAssociated_address_address_int64_Event.OutputTuple,
    TokenAssociated_address_address_int64_Event.OutputObject
  >;
  getEvent(
    key: "TokenCreated"
  ): TypedContractEvent<
    TokenCreatedEvent.InputTuple,
    TokenCreatedEvent.OutputTuple,
    TokenCreatedEvent.OutputObject
  >;
  getEvent(
    key: "TokenCreated(address,int64)"
  ): TypedContractEvent<
    TokenCreated_address_int64_Event.InputTuple,
    TokenCreated_address_int64_Event.OutputTuple,
    TokenCreated_address_int64_Event.OutputObject
  >;
  getEvent(
    key: "TokenMinted"
  ): TypedContractEvent<
    TokenMintedEvent.InputTuple,
    TokenMintedEvent.OutputTuple,
    TokenMintedEvent.OutputObject
  >;
  getEvent(
    key: "TokenMinted(address,uint256,int64)"
  ): TypedContractEvent<
    TokenMinted_address_uint256_int64_Event.InputTuple,
    TokenMinted_address_uint256_int64_Event.OutputTuple,
    TokenMinted_address_uint256_int64_Event.OutputObject
  >;
  getEvent(
    key: "TokenTransferred"
  ): TypedContractEvent<
    TokenTransferredEvent.InputTuple,
    TokenTransferredEvent.OutputTuple,
    TokenTransferredEvent.OutputObject
  >;
  getEvent(
    key: "TokenTransferred(address,address,address,uint256,int64)"
  ): TypedContractEvent<
    TokenTransferred_address_address_address_uint256_int64_Event.InputTuple,
    TokenTransferred_address_address_address_uint256_int64_Event.OutputTuple,
    TokenTransferred_address_address_address_uint256_int64_Event.OutputObject
  >;

  filters: {
    "TokenAssociated(address,address,int64)": TypedContractEvent<
      TokenAssociatedEvent.InputTuple,
      TokenAssociatedEvent.OutputTuple,
      TokenAssociatedEvent.OutputObject
    >;
    TokenAssociated: TypedContractEvent<
      TokenAssociatedEvent.InputTuple,
      TokenAssociatedEvent.OutputTuple,
      TokenAssociatedEvent.OutputObject
    >;

    "TokenCreated(address,int64)": TypedContractEvent<
      TokenCreatedEvent.InputTuple,
      TokenCreatedEvent.OutputTuple,
      TokenCreatedEvent.OutputObject
    >;
    TokenCreated: TypedContractEvent<
      TokenCreatedEvent.InputTuple,
      TokenCreatedEvent.OutputTuple,
      TokenCreatedEvent.OutputObject
    >;

    "TokenMinted(address,uint256,int64)": TypedContractEvent<
      TokenMintedEvent.InputTuple,
      TokenMintedEvent.OutputTuple,
      TokenMintedEvent.OutputObject
    >;
    TokenMinted: TypedContractEvent<
      TokenMintedEvent.InputTuple,
      TokenMintedEvent.OutputTuple,
      TokenMintedEvent.OutputObject
    >;

    "TokenTransferred(address,address,address,uint256,int64)": TypedContractEvent<
      TokenTransferredEvent.InputTuple,
      TokenTransferredEvent.OutputTuple,
      TokenTransferredEvent.OutputObject
    >;
    TokenTransferred: TypedContractEvent<
      TokenTransferredEvent.InputTuple,
      TokenTransferredEvent.OutputTuple,
      TokenTransferredEvent.OutputObject
    >;
  };
}
